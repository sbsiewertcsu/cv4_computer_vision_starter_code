// This code was generated by ChatGPT 4.0
//
// It does not run faster!!
//
// I finally gave up trying to run a simple fibonnaci(93). Here's the sad results:
//
// sbsiewert@ecc-linux2:~/public_html/csci551/code/hello_openmp$ time ./fib 32
// will compute Fibonacci of 32
// fibnum=2178309 for thread 0
// g_fibnum=2178309 in 0.000010 seconds
// 
// real    0m0.001s
// user    0m0.001s
// sys     0m0.000s
// sbsiewert@ecc-linux2:~/public_html/csci551/code/hello_openmp$ time ./fibgpt 32
// Fibonacci(32) = 2178309
// 
// real    0m3.449s
// user    0m3.265s
// sys     0m1.036s
// sbsiewert@ecc-linux2:~/public_html/csci551/code/hello_openmp$ time ./fib 93
// will compute Fibonacci of 93
// fibnum=12200160415121876738 for thread 0
// g_fibnum=12200160415121876738 in 0.000010 seconds
// 
// real    0m0.001s
// user    0m0.001s
// sys     0m0.000s
// sbsiewert@ecc-linux2:~/public_html/csci551/code/hello_openmp$ time ./fibgpt 93
// ^C
// 
// real    5m37.172s
// user    11m8.720s
// sys     0m0.787s
//
//
// This shows how challenging a simple parallel sequence like fibonacci can be.
//
// For the record, here's teh ChatGPT prompt that generated this code as a response.
//
// Prompt:
// ------
// Can you rewrite this program so that the parallel computation completes faster than
// the sequential - https://www.ecst.csuchico.edu/~sbsiewert/csci551/code/hello_sequences/fibgpt1.c
//
// ChatGPT 4.0 Response:
// --------------------
// Sure, here's a possible implementation of the Fibonacci sequence computation that should be faster
// in parallel than the sequential version you provided. The key idea is to divide the range of Fibonacci
// numbers to be computed among the available threads, and use a divide-and-conquer approach to compute the
// intermediate Fibonacci numbers needed to compute each range. This can reduce the amount of duplicated work
// and synchronization overhead that can occur when parallelizing the sequential loop.
//
// Notes:
// -----
// In this implementation, we use OpenMP tasks to divide the computation of the Fibonacci numbers
// into smaller sub-tasks that can be executed in parallel. The fib function is now a recursive function
// that computes the n-th Fibonacci number by recursively computing the n-1 and n-2 Fibonacci numbers using
// OpenMP tasks. The taskwait directive ensures that the two sub-tasks are completed before their results
// are added together.
//
// The main function now creates a single task to compute the n-th Fibonacci number using fib(n), and waits
// for the task to complete using the single directive. The result variable is now a uint128_t to handle the
// larger Fibonacci numbers that can be computed using this implementation.
// 
// This implementation should be faster than the sequential version when the number of Fibonacci numbers to
// compute is large, and there are enough available threads to take advantage of the parallelism. However, as
// with any parallel implementation, there may be some overhead due to thread creation and synchronization, so
// the performance may not scale perfectly with the number of available threads.
//


#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

typedef unsigned __int128 uint128_t;

uint128_t fib(int n);

int main(int argc, char **argv) {
    int n;
    uint128_t result = 0;

    if (argc != 2) {
        printf("Usage: %s n\n", argv[0]);
        return 1;
    }

    n = atoi(argv[1]);

    #pragma omp parallel
    #pragma omp single
    result = fib(n);

    printf("Fibonacci(%d) = %llu\n", n, (unsigned long long)result);

    return 0;
}

uint128_t fib(int n) {
    if (n < 2)
        return n;

    uint128_t f1, f2;

    #pragma omp task shared(f1)
    f1 = fib(n-1);

    #pragma omp task shared(f2)
    f2 = fib(n-2);

    #pragma omp taskwait

    return f1 + f2;
}

